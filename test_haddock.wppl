// test

var r1 = ["rabbit", "bag", 1]
var r2 = ["rabbit", "bag", 2]
var r3 = ["frog", "box", 3]
var r4 = ["rabbit", "box", 1]
var r5 = ["rabbit", "box", 2]
var rU = ["", "", ""]

var referents = [r1, r2, r3, r4, r5, rU]

var alpha = 1;

var descriptions = [["rabbit","big","bag"],["rabbit","big","box"],["rabbit","bigger","bag"],["rabbit","bigger","box"],["rabbit","small","bag"],["rabbit","small","box"],["rabbit","smaller","bag"],["rabbit","smaller","box"],["rabbit","empty","bag"],["rabbit","empty","box"],["frog","bigger","box"],["frog","small","box"],["frog","empty","box"],["frog","bigger","basket"],["frog","small","basket"],["frog","empty","basket"],["none","none","none"]];

var randomVariable = [["rabbit","big","box"],["rabbit","big","bag"]];

var randomVariablePrior = function() {
   return uniformDraw(randomVariable);
} // this is not a distribution in webppl. if i want to sample() from this i have to use the infer wrapping here


var refs = {
  "referents": [r1, r2, r3, r4, r5, rU],
  "probabilities": [50, 50, 50, 50, 50, 10]
};

var referentsPrior = function() {
  return categorical(refs.probabilities, refs.referents);
};

var cont1 =[[r1,r2,r3,r4,r5]]
var cont2 =[
[r1],[r2],[r3],[r4],[r5],
[r1,r2],
[r1,r3],
[r1,r4],
[r1,r5],
[r2,r3],
[r2,r4],
[r2,r5],
[r3,r4],
[r3,r5],
[r4,r5],

[r1,r2,r3],
[r1,r2,r4],
[r1,r2,r5],
[r1,r3,r4],
[r1,r3,r5],
[r1,r4,r5],
[r2,r3,r4],
[r2,r3,r5],
[r2,r4,r5],
[r3,r4,r5],

[r1,r2,r3,r4],
[r1,r2,r3,r5],
[r1,r2,r4,r5],
[r1,r3,r4,r5],
[r2,r3,r4,r5],

[r1,r2,r3,r4,r5]
              ]


var conts = function(cont) {

  if (cont == "no-cc") {

    return cont1

  }

  else {

    return cont2
  }
}

var contexts = conts("no-cc")

// display(contexts)

var thresholds = ["0", "1", "2", "3"]


var cost = {
  "rabbit bigger bag": 1.5,
  "frog bigger basket": 1.5,
  "rabbit bigger box": 1.5,
  "frog bigger box": 1.5,
  "rabbit smaller bag": 1.5,
  "frog smaller basket": 1.5,
  "rabbit smaller box": 1.5,
  "frog smaller box": 1.5,
  "rabbit big bag": 1,
  "frog big basket": 1,
  "rabbit big box": 1,
  "frog big box": 1,
  "rabbit small bag": 1,
  "frog small basket": 1,
  "rabbit small box": 1,
  "frog small box": 1,
  "rabbit empty bag": 0.5,
  "frog empty box": 0.5,
  "frog empty basket": 0.5,
  "rabbit empty box": 0.5,
  "none none none": 0,
};


// Functions //

var randomVariablePrior = function() {
   return uniformDraw(randomVariable);
} // this is not a distribution in webppl. if i want to sample() from this i have to use the infer wrapping here

var referentsPrior = function() {
  return categorical(refs.probabilities, refs.referents);
};

//threshold prior relativized to the descriptions's relevant comparison class, k+1 thresholds
var thresholdPriorGivenContext = function(context, description) {
  var cc = function(context, description){
  filter(function(rf){
  rf[1] == description[2]
  }, context) 
  };
  var result = cc(context,description);
  display(result)
  var getThres = map(function(result){ return result[2] }, result )
  getThres.sort()
  getThres.push(getThres[0] - 1);
  return Infer({method: "enumerate"}, function() {
  uniformDraw(getThres)
  });
};


var referentsPriorGivenContext = function(context) {
  return Infer({method: "enumerate"}, function() {
     flip(0.01) ? rU : uniformDraw(context)
  });
};

var contextsPrior = function() {
    return uniformDraw(contexts);
}

var descriptionPrior = function() {
  var uttProbs = map(function(u) {
    var uKey = typeof u == "string" ? u : u[0] + " " + u[1] + " " + u[2];
         return Math.exp(-cost[uKey])
  }, descriptions);
    return categorical(uttProbs, descriptions);
};

var thresholdsPrior = function() {
    return uniformDraw(thresholds);
}



//// Meaning Function ////

// Positive Function


var positiveStand = function(description, referent, all_referents, theta, context) {

  var innerMatch = function(referent) {

    var sameContainer = description[2] == referent[1] ? true : false
    return sameContainer == true 

  }

  var truthFn = function(referent) {

    var includes = find(function(x) {return x == referent}, context) 
    var inclusion = includes == referent ? true : false
    var sameNoun = description[0] == referent[0] ? true : false
    var threshold =  description[1] == "empty" ? true: description[1] == "big" ? referent[2] > theta : description[1] == "small" ? referent[2] <= theta : false

    return inclusion == true && sameNoun == true && threshold == true && innerMatch(referent)== true && sum(map(innerMatch, all_referents))==1

  }

  return (truthFn(referent) && sum(map(truthFn, all_referents))==1) || _.isEqual(description, ["none", "none", "none"]) || _.isEqual(referent, rU)

}



var positiveBum = function(description, referent, all_referents, theta, context) {

  var innerMatch = function(referent) {

    var sameContainer = description[2] == referent[1] ? true : false
    return sameContainer == true 

  }

  var truthFn = function(referent) {

    var includes = find(function(x) {return x == referent}, context) 
    var inclusion = includes == referent ? true : false
    var sameNoun = description[0] == referent[0] ? true : false
    var threshold =  description[1] == "empty" ? true: description[1] == "big" ? referent[2] > theta : description[1] == "small" ? referent[2] <= theta : false

    return inclusion == true && sameNoun == true && threshold == true && innerMatch(referent)

  }

  return (truthFn(referent) && sum(map(truthFn, all_referents))==1) || _.isEqual(description, ["none", "none", "none"]) || _.isEqual(referent, rU)

}


var positiveMeaning = "standard"

var pos = function(positiveMeaning) {

  if (positiveMeaning == "standard") {

    return positiveStand

  }

  else {

    return positiveBum
  }
}


var positive = pos(positiveMeaning)



// Comparative Function
var comparative = function(description, referent, all_referents, theta, context) {

  var innerMatch = function(referent) {

    var sameContainer = description[2] == referent[1] ? true : false

    return sameContainer == true

  }

  var truthFn = function(referent) {

    var includes = find(function(x) { return x == referent }, context) 
    var inclusion = includes == referent ? true : false 
    var sameNoun = description[0] == referent[0]  ? true : false 
    
    return sameNoun == true && inclusion == true && innerMatch(referent)

  }
  
  var cardinalityCheck = function(scope) {
    
    if (scope == "low") {
      return description[1] == "empty" ? true : description[1] == "bigger" ? sum(map(innerMatch, all_referents)) == 2 : false
    } 

    else {
      return description[1] == "empty" ? true : description[1] == "bigger" ? sum(map(truthFn, all_referents)) == 2 : false
    }
    
  }

  var thresholdFn = function(referent, scope) {

    var threshold =  description[1] == "empty" ? true : description[1] == "bigger" ? referent[2] > theta : description[1] == "smaller" ? referent[2] <= theta : false

    return (threshold == true && cardinalityCheck(scope) == true && truthFn(referent)) || _.isEqual(description, ["none", "none", "none"]) || _.isEqual(referent, rU)

  }
  
  return sample(Infer({method: "enumerate"}, function() {flip(0.05) ? thresholdFn(referent, "low") : thresholdFn(referent, "high")}))
  
}

var meaning = function(description, referent, all_referents, theta, context) {

  var adjective = description[1]

  if (adjective.substr(-2) == "er") {

    return comparative(description, referent, all_referents, theta, context)

  }

  else {

    return positive(description, referent, all_referents, theta, context)

  }

}

//// End of Meaning Function ////


var literalListener = function(description, context, theta) { //pos
    return Infer({method: "enumerate"}, function() {
    var referent = referentsPrior();
    var all_referents = context; 
    condition(meaning(description, referent, all_referents, theta, context))
    return referent;
  });
} 

var speaker = function(referent, context, theta) {
  return Infer({method: "enumerate"}, function() {
    var description = descriptionPrior();
    factor(alpha * literalListener(description, context, theta).score(referent))
    return description;
  });
}

var pragmaticListener = function(description) {
  return Infer({method: "enumerate"}, function() {
    var description = randomVariablePrior();
    var context = contextsPrior(); 
    var referent = sample(referentsPriorGivenContext(context));
    var theta = sample(thresholdPriorGivenContext(context,description)); 
    factor(speaker(referent, context, theta).score(description));
    condition(referent[0]=="rabbit")
    return {thet: theta, cont: context, ref: referent}; 
  });
};


// Main

// marginalize(pragmaticListener(["boo","boo","silence"]), "ref") //aixo corr!!!

// thresholdPriorGivenContext([r1,r2,r3,r4,r5], ["rabbit","big","bag"])

// positive(["rabbit","big","bag"], r2, [r1,r2,r3,r4,r5], 1, [r1,r2,r3,r4,r5])

// positive(["rabbit","big","bag"], r1, [r1,r2,r3], 0, [r1,r2,r3])

// literalListener(["rabbit","big","bag"],[r1,r2],1)

// literalListener(["rabbit","big","box"],[r1,r2,r3,r4,r5],1)

// pragmaticListener(["rabbit","big","bag"]) //for tomorrow check what happens in condition 1 for this instruction. DO I have similations for this??

// meaning(["rabbit","big","box"], r5, [r1,r2,r3,r4,r5], 1, [r1,r2,r3,r4,r5]) 


 // speaker(r3,[r1,r2,r3,r4,r5],1)
//TODO: compress 4 models in one single script, add script with pragmaticlistener2 to repository

marginalize(pragmaticListener(["rabbit","big","silence"]), "ref")
