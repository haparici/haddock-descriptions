// test

var r1 = ["rabbit", "bag", 1]
var r2 = ["rabbit", "bag", 2]
var r3 = ["frog", "basket", 3]
var r4 = ["frog", "box", 1]
var r5 = ["rabbit", "box", 2]
var rU = ["", "", ""]

var referents = [r1, r2, r3, r4, r5, rU]

var alpha = 1;

var descriptions = [["rabbit","big","bag"],["rabbit","big","box"],["rabbit","bigger","bag"],["rabbit","bigger","box"],["rabbit","small","bag"],["rabbit","small","box"],["rabbit","smaller","bag"],["rabbit","smaller","box"],["rabbit","empty","bag"],["rabbit","empty","box"],["frog","bigger","box"],["frog","small","box"],["frog","empty","box"],["frog","bigger","basket"],["frog","small","basket"],["frog","empty","basket"],["none","none","none"]];

var randomVariable = [["rabbit","bigger","box"],["rabbit","bigger","bag"]];

var randomVariablePrior = function() {
   return uniformDraw(randomVariable);
} // this is not a distribution in webppl. if i want to sample() from this i have to use the infer wrapping here


var refs = {
  "referents": [r1, r2, r3, r4, r5, rU],
  "probabilities": [50, 50, 50, 50, 50, 10]
};

var referentsPrior = function() {
  return categorical(refs.probabilities, refs.referents);
};

var contexts =[

    [r1], [r2], [r3], [r4], [r5],

    [r1, r2],
    [r1, r3],
    [r1, r4],
    [r1, r5],
    [r2, r3],
    [r2, r4],
    [r2, r5],
    [r3, r4],
    [r3, r5],
    [r4, r5],

    [r1, r2, r3],
    [r1, r2, r4],
    [r1, r2, r5],
    [r1, r3, r4],
    [r1, r3, r5],
    [r1, r4, r5],
    [r2, r3, r4],
    [r2, r3, r5],
    [r2, r4, r5],
    [r3, r4, r5],

    [r1, r2, r3, r4],
    [r1, r2, r3, r5],
    [r1, r2, r4, r5],
    [r1, r3, r4, r5],
    [r2, r3, r4, r5],

    [r1,r2,r3,r4,r5]
]

var thresholds = ["0", "1", "2", "3"]


var cost = {
  "rabbit bigger bag": 1.5,
  "frog bigger basket": 1.5,
  "rabbit bigger box": 1.5,
  "frog bigger box": 1.5,
  "rabbit smaller bag": 1.5,
  "frog smaller basket": 1.5,
  "rabbit smaller box": 1.5,
  "frog smaller box": 1.5,
  "rabbit big bag": 1,
  "frog big basket": 1,
  "rabbit big box": 1,
  "frog big box": 1,
  "rabbit small bag": 1,
  "frog small basket": 1,
  "rabbit small box": 1,
  "frog small box": 1,
  "rabbit empty bag": 0.5,
  "frog empty box": 0.5,
  "frog empty basket": 0.5,
  "rabbit empty box": 0.5,
  "none none none": 0,
};


// Functions //

var randomVariablePrior = function() {
   return uniformDraw(randomVariable);
} // this is not a distribution in webppl. if i want to sample() from this i have to use the infer wrapping here

var referentsPrior = function() {
  return categorical(refs.probabilities, refs.referents);
};

//threshold prior relativized to the descriptions's relevant comparison class, k+1 thresholds
var thresholdPriorGivenContext = function(context, description) {

  var cc = function(context, description){
  filter(function(rf){
  rf[1] == description[2]
  }, context) 
  };
  var result = cc(context,description);
  var min_result = Math.min.apply(null, result);
  result.push(min_result - 1);
  result.sort()
  return Infer({method: "enumerate"}, function() {
  var thres = map(function(result){ return result[2] }, result )
  uniformDraw(thres)
  });
};


var referentsPriorGivenContext = function(context) {
  return Infer({method: "enumerate"}, function() {
     flip(0.01) ? rU : uniformDraw(context)
  });
};

var contextsPrior = function() {
    return uniformDraw(contexts);
}

var descriptionPrior = function() {
  var uttProbs = map(function(u) {
    var uKey = typeof u == "string" ? u : u[0] + " " + u[1] + " " + u[2];
         return Math.exp(-cost[uKey])
  }, descriptions);
    return categorical(uttProbs, descriptions);
};

var thresholdsPrior = function() {
    return uniformDraw(thresholds);
}



//// Meaning Function ////

// Positive Function
var positive = function(description, referent, all_referents, theta, context) {

  var innerMatch = function(referent) {

    var sameContainer = description[2] == referent[1] ? true : false
    return sameContainer == true 

  }

  var truthFn = function(referent) {

    var includes = find(function(x) {return x == referent}, context) 
    var inclusion = includes == referent ? true : false
    var sameNoun = description[0] == referent[0] ? true : false
    var threshold =  description[1] == "empty" ? true: description[1] == "big" ? referent[2] > theta : description[1] == "small" ? referent[2] <= theta : false

    return inclusion == true && sameNoun == true && threshold == true && innerMatch(referent)

  }

  return (truthFn(referent) && sum(map(truthFn, all_referents))==1) || _.isEqual(description, ["none", "none", "none"]) || _.isEqual(referent, rU)

}

//return result ? Bernoulli({p: 1.0}) : Bernoulli({p: 0.0})


// Comparative Function
var comparative = function(description, referent, all_referents, theta, context) {

  var innerMatch = function(referent) {

    var sameContainer = description[2] == referent[1] ? true : false

    return sameContainer == true

  }

  var truthFn = function(referent) {

    var includes = find(function(x) { return x == referent }, context) 
    var inclusion = includes == referent ? true : false 
    var sameNoun = description[0] == referent[0]  ? true : false 
    
    return sameNoun == true && inclusion == true && innerMatch(referent)

  }
  
  var cardinalityCheck = function(scope) {
    
    if (scope == "low") {
      return description[1] == "empty" ? true : description[1] == "bigger" ? sum(map(innerMatch, all_referents)) == 2 : false
    } 

    else {
      return description[1] == "empty" ? true : description[1] == "bigger" ? sum(map(truthFn, all_referents)) == 2 : false
    }
    
  }

  var thresholdFn = function(referent, scope) {

    var threshold =  description[1] == "empty" ? true : description[1] == "bigger" ? referent[2] > theta : description[1] == "smaller" ? referent[2] <= theta : false

    return (threshold == true && cardinalityCheck(scope) == true && truthFn(referent)) || _.isEqual(description, ["none", "none", "none"]) || _.isEqual(referent, rU)

  }
  
  return sample(Infer({method: "enumerate"}, function() {flip(0.05) ? thresholdFn(referent, "low") : thresholdFn(referent, "high")}))
  
}

var meaning = function(description, referent, all_referents, theta, context) {

  var adjective = description[1]

  if (adjective.substr(-2) == "er") {

    return comparative(description, referent, all_referents, theta, context)

  }

  else {

    return positive(description, referent, all_referents, theta, context)

  }

}

//// End of Meaning Function ////


var literalListener = function(description, context, theta) { //pos
    return Infer({method: "enumerate"}, function() {
    var referent = referentsPrior();
    var all_referents = context; 
    condition(meaning(description, referent, all_referents, theta, context))
    return referent;
  });
} 

var speaker = function(referent, context, theta) {
  return Infer({method: "enumerate"}, function() {
    var description = descriptionPrior();
    factor(alpha * literalListener(description, context, theta).score(referent))
    return description;
  });
}

var pragmaticListener = function(description) {
  return Infer({method: "enumerate"}, function() {
    var description = randomVariablePrior();
    var context = contextsPrior(); 
    var referent = sample(referentsPriorGivenContext(context));
    // display(JSON.stringify(referent))
    var theta = sample(thresholdPriorGivenContext(context,description)); 
    factor(speaker(referent, context, theta).score(description));
    condition(referent[0]=="rabbit")
    return {thet: theta, cont: context, ref: referent}; 
  });
};


// Main

//problemes: quan settings meanin positive, bigger dona lo mateix q big. Quan setting meanings bigger, big dona igual q bigger a nivell de pragmatic listner
//lo raro es q si corrs positive or comparative per separat dona true or false de forma correcte. p q quan passes per pragmaticlistener amb nomes comp. or nomes pos. accepta big bigger i no fa cas de container??
//conclusio: algo passa amb pragmatic listener
//tampoc peta si randomvariable nomes inclo big o bigger. si que peta si nomes tens positve or comparative i si redueixes random variable a 2 q no quadrin
//conclusio: random variable ha d ser es parell correct si es positive i ha de ser saltre parell si es comparative. claro aixo es lo q determina ses coses!!

marginalize(pragmaticListener(["boo","boo","silence"]), "ref")



// positive(["rabbit","big","bag"], r2, [r1,r2,r3], 1, [r1,r2,r3])

// literalListener(["rabbit","big","bag"],[r1,r2,r3,r4,r5],1)

// literalListener(["rabbit","big","box"],[r1,r2,r3,r4,r5],1)

// pragmaticListener(["rabbit","big","box"])

// meaning(["rabbit","big","box"], r2, [r1,r2,r3,r4,r5], 1, [r1,r2,r3,r4,r5]) //this is false with meaning as positive


// speaker(r5,[r1,r2,r3,r4,r5],1)
//TODO: compress 4 models in one single script, add script with pragmaticlistener2 to repository

// viz.table(marginalize(pragmaticListener(["rabbit","bigger","silence"]), "ref"))