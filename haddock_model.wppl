
// Parameters and Variables
var randomVariable= model_data[0]
var visuals = model_data[1]
var descriptions = model_data[2]
var cost = model_data[3][0]
var cont = model_data[4]
var posMeaning = model_data[5]


var r1 = [visuals[0]["Animal"][0], visuals[0]["Container"][0], visuals[0]["Size"][0]]
var r2 = [visuals[1]["Animal"][0], visuals[1]["Container"][0], visuals[1]["Size"][0]]
var r3 = [visuals[2]["Animal"][0], visuals[2]["Container"][0], visuals[2]["Size"][0]]
var r4 = [visuals[3]["Animal"][0], visuals[3]["Container"][0], visuals[3]["Size"][0]]
var r5 = [visuals[4]["Animal"][0], visuals[4]["Container"][0], visuals[4]["Size"][0]]
var rU = ["", "", ""]

var referents = [r1, r2, r3, r4, r5, rU]

var alpha = 1;

var refs = {
  "referents": [r1, r2, r3, r4, r5, rU],
  "probabilities": [50, 50, 50, 50, 50, 10]
};


var cont1 = [[r1,r2,r3,r4,r5]]
var cont2 = [

    [r1], [r2], [r3], [r4], [r5],

    [r1, r2],
    [r1, r3],
    [r1, r4],
    [r1, r5],
    [r2, r3],
    [r2, r4],
    [r2, r5],
    [r3, r4],
    [r3, r5],
    [r4, r5],

    [r1, r2, r3],
    [r1, r2, r4],
    [r1, r2, r5],
    [r1, r3, r4],
    [r1, r3, r5],
    [r1, r4, r5],
    [r2, r3, r4],
    [r2, r3, r5],
    [r2, r4, r5],
    [r3, r4, r5],

    [r1, r2, r3, r4],
    [r1, r2, r3, r5],
    [r1, r2, r4, r5],
    [r1, r3, r4, r5],
    [r2, r3, r4, r5],

    [r1,r2,r3,r4,r5]
]



var conts = function(cont) {

  if (cont == "no-cc") {

    return cont1

  }

  else {

    return cont2
  }
}


var contexts = conts(cont)



var thresholds = ["0", "1", "2", "3"]


var thres = {
  "thresholds": ["0", "1", "2", "3"],
  "probabilities": [10, 60, 60, 10]
};


var thresholdsPrior = function() {
    return categorical(thres.probabilities, thres.thresholds)
}  //make this not uniform



// Functions //

var randomVariablePrior = function() {
   return uniformDraw(randomVariable);
} // this is not a distribution in webppl. if i want to sample() from this i have to use the infer wrapping here

var referentsPrior = function() {
  return categorical(refs.probabilities, refs.referents);
};


//threshold prior relativized to the descriptions's relevant comparison class, k+1 thresholds only for singleton contexts
// var thresholdPriorGivenContext = function(context, description) {
//   var cc = function(context, description){
//   filter(function(rf){
//   rf[1] == description[2]
//   }, context) 
//   };
//   var result = cc(context,description);
//   display(result)
//   var getThres = map(function(result){ return result[2] }, result )
//   // getThres.sort()
//   // display(getThres)
//   // var extendThres = getThres.slice(0)
//   // extendThres.push(extendThres[0] - 1) 
//   // display(getThres)
//   // display(getThres.length)
//   // var addThres = getThres.length == 1 ? extendThres : getThres
//   // display(addThres)
//   return Infer({method: "enumerate"}, function() {
//   uniformDraw(getThres)
//   });
// };



var thresholdPriorGivenContext  = function(context,description) {
    
  var cc = function(context, description){
    filter(function(rf){
    rf[1] == description[2]
    }, context) 
    };
  var result = cc(context,description);
    return Infer({method: "enumerate"}, function() {
      var getThres = map(function(result){ return result[2] }, result )
      var extendThres = getThres.slice(0)
      extendThres.push(extendThres[0] - 1) 
      uniformDraw(extendThres)
  });
};



var referentsPriorGivenContext = function(context) {
  return Infer({method: "enumerate"}, function() {
     flip(0.01) ? rU : uniformDraw(context)
  });
};

var contextsPrior = function() {
    return uniformDraw(contexts);
}  


var max_number_of_elements = 5

var priorDistribution = function(contexts, skewedness) {
  
  var beta_dist =  Beta({a: skewedness, b: 1})
  var context_length = max_number_of_elements
//   var readout_values = _.range(0, context_length) // get the array
//   var readout_values = map(function(x) { return x / (context.length-1); }, readout_values); // normalize it 
//   readout_values[0] = 0.00001 //this doesn't work
//   readout_values[context_length-1] = 0.99999 //this doesn't work
  
  var readout_values = [0.00001,0.25,0.5,0.75,0.999999] // this should be an array of length 'number of elements in the biggest context possible'
  // that evenly spans the range from 0 to 1 (but excluding 0 and 1)
  
  var unnormalized_p = map(function(x) { return Math.exp(beta_dist.score(x)); }, readout_values);
  
  var categorical_p_unnormalized = map(function(set) {unnormalized_p[set.length-1]}, contexts)
  var categorical_p_normalized = map(function(x) { return x / sum(categorical_p_unnormalized); }, categorical_p_unnormalized);
  
  return Categorical({ps: categorical_p_normalized, vs: contexts})
}
// renormalize because it does not sum up to 1

var priorContextSkewed = priorDistribution(contexts, 2)


var descriptionPrior = function() {
  var uttProbs = map(function(u) {
    var uKey = typeof u == "string" ? u : u[0] + " " + u[1] + " " + u[2];
         return Math.exp(-cost[uKey])
  }, descriptions);
    return categorical(uttProbs, descriptions);
};

// var thresholdsPrior = function() {
//     return uniformDraw(thrs);
// }  //make this not uniform

var pragmaticListenerFullDescription = function(description) {
  return Infer({method: "enumerate"}, function() {
    var context = contextsPrior(); 
    var referent = referentsPrior();
    // var referent = sample(referentsPriorGivenContext(context));
    var theta = sample(thresholdPriorGivenContext(context,description)); 
    factor(speaker(referent, context, theta).score(description));
    // condition(referent[0]=="rabbit")
    return {thet: theta, cont: context, ref: referent}; 
  });
};

var descriptionPrior1 = function() {
return uniformDraw(descriptions);
};


//// Meaning Function ////

// Positive Function

// var positiveStand = function(description, referent, all_referents, theta, context) {

//   var innerMatch = function(referent) {

//     var sameContainer = description[2] == referent[1] ? true : false
//     return sameContainer == true 

//   }

//   var truthFn = function(referent) {

//     var includes = find(function(x) {return x == referent}, context) 
//     var inclusion = includes == referent ? true : false
//     var sameNoun = description[0] == referent[0] ? true : false
//     var threshold =  description[1] == "empty" ? true: description[1] == "big" ? referent[2] > theta : description[1] == "small" ? referent[2] <= theta : false

//     return inclusion == true && sameNoun == true && threshold == true && innerMatch(referent)== true && sum(map(innerMatch, all_referents))==1

//   }

//   return (truthFn(referent) && sum(map(truthFn, all_referents))==1) || _.isEqual(description, ["none", "none", "none"]) || _.isEqual(referent, rU)

// }

var positiveStand = function(description, referent, all_referents, theta, context) {
    
  var innerMatch = function(referent) {
    var includes = find(function(x) { return x == referent }, context) 
    // display(includes)
    var inclusion = includes == referent ? true : false 
      // display(inclusion)
    var sameContainer = description[2] == referent[1] ? true : false 
    // display(sameContainer)
    var threshold =  description[1] == "empty" ? true : description[1] == "big" ? referent[2] > theta : description[1] == "small" ? referent[2] <= theta : false 
    //       display(threshold)
    inclusion == true && sameContainer == true && threshold == true
  }
  
  var truthFn = function(referent){

      var includes = find(function(x) { return x == referent }, context) 
      // display(includes)
      var inclusion = includes == referent ? true : false 
      // display(inclusion)
      var sameNoun = description[0] == referent[0]  ? true : false 
      // display(sameNoun)
      
      innerMatch(referent)==true && sum(map(innerMatch, all_referents))==1 && sameNoun == true && inclusion == true
     
  }
  
  return (truthFn(referent) && sum(map(truthFn, all_referents))==1) || _.isEqual(description, ["none", "none", "none"]) || _.isEqual(referent, rU)

}

var positiveBum = function(description, referent, all_referents, theta, context) {

  var innerMatch = function(referent) {

    var sameContainer = description[2] == referent[1] ? true : false

    return sameContainer == true 

  }

  var truthFn = function(referent) {

    var includes = find(function(x) {return x == referent}, context) 
    var inclusion = includes == referent ? true : false
    var sameNoun = description[0] == referent[0] ? true : false
    var threshold =  description[1] == "empty" ? true: description[1] == "big" ? referent[2] > theta : description[1] == "small" ? referent[2] <= theta : false

    return inclusion == true && sameNoun == true && threshold == true && innerMatch(referent)

   }

  return (truthFn(referent) && sum(map(truthFn, all_referents))==1) || _.isEqual(description, ["none", "none", "none"]) || _.isEqual(referent, rU)

}




var pos = function(posMeaning) {

  if (posMeaning == "standard") {

    return positiveStand

  }

  else {

    return positiveBum
  }
}


var positive = pos(posMeaning)


// Comparative Function
var comparative = function(description, referent, all_referents, theta, context) {

  var innerMatch = function(referent) {

    var sameContainer = description[2] == referent[1] ? true : false

    return sameContainer == true

  }

  var truthFn = function(referent) {

    var includes = find(function(x) { return x == referent }, context) 
    var inclusion = includes == referent ? true : false 
    var sameNoun = description[0] == referent[0]  ? true : false 
    
    return sameNoun == true && inclusion == true && innerMatch(referent)

  }
  
  var cardinalityCheck = function(scope) {
    
    if (scope == "low") {
      return description[1] == "empty" ? true : description[1] == "bigger" ? sum(map(innerMatch, all_referents)) == 2 : false
    } 

    else {
      return description[1] == "empty" ? true : description[1] == "bigger" ? sum(map(truthFn, all_referents)) == 2 : false
    }
    
  }

  var thresholdFn = function(referent, scope) {

    var threshold =  description[1] == "empty" ? true : description[1] == "bigger" ? referent[2] > theta : description[1] == "smaller" ? referent[2] <= theta : false

    return (threshold == true && cardinalityCheck(scope) == true && truthFn(referent)) || _.isEqual(description, ["none", "none", "none"]) || _.isEqual(referent, rU)

  }
  
  return sample(Infer({method: "enumerate"}, function() {flip(0.000001) ? thresholdFn(referent, "low") : thresholdFn(referent, "high")}))
  
}

var meaning = function(description, referent, all_referents, theta, context) {

  var adjective = description[1]

  if (adjective.substr(-2) == "er") {

    return comparative(description, referent, all_referents, theta, context)

  }

  else {

    return positive(description, referent, all_referents, theta, context)

  }

}

//// End of Meaning Function ////

var literalListener = function(description, context, theta) {
    return Infer({method: "enumerate"}, function() {
    var referent = referentsPrior();
    var all_referents = context; 
    condition(meaning(description, referent, all_referents, theta, context))
    return referent;
  });
}

var speaker = function(referent, context, theta) {
  return Infer({method: "enumerate"}, function() {
    var description = descriptionPrior();
    factor( alpha * literalListener(description, context, theta).score(referent));
    return description;
  });
}

var pragmaticListener = function(description) {
  return Infer({method: "enumerate"}, function() {
    var description = randomVariablePrior();
    var context = sample(priorContextSkewed); 
    //var context = contextsPrior(); 
    var referent = sample(referentsPriorGivenContext(context));
    var theta = sample(thresholdPriorGivenContext(context,description)); 
    factor(speaker(referent, context, theta).score(description));
    condition(referent[0]=="rabbit")
    return {thet: theta, cont: context, ref: referent}; 
  });
}


var pragmaticListenerFullDescription = function(description) {
  return Infer({method: "enumerate"}, function() {
    var context = contextsPrior(); 
    //var referent = referentsPrior();
    var referent = sample(referentsPriorGivenContext(context));
    var theta = sample(thresholdPriorGivenContext(context,description)); 
    factor(speaker(referent, context, theta).score(description));
    // condition(referent[0]=="rabbit")
    return {thet: theta, cont: context, ref: referent}; 
  });
}


var speaker1 = function(referent) {
  return Infer({method: "enumerate"}, function() {
    var description = descriptionPrior();
    factor( alpha * marginalize(pragmaticListenerFullDescription(description),"ref").score(referent));
    return description;
  });
}



var pragmaticListener2 = function(description) {
  return Infer({method: "enumerate"}, function() {
    var description = randomVariablePrior();
    // var context = contextsPrior(); 
    // var referent = sample(referentsPriorGivenContext(context));
//     display(JSON.stringify(referent))
    // var theta = sample(tresholdPriorGivenContext(context,description)); 
    var referent = referentsPrior();
    factor(speaker1(referent).score(description));
    condition(referent[0]=="rabbit")
    return referent; 
  });
}





// Main

marginalize(pragmaticListener("rabbit","adjective","silence"), "ref")

