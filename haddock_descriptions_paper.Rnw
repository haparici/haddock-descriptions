\documentclass[letterpaper, 12pt]{article}
%\usepackage{liatex85}
\usepackage{etex}
\usepackage{geometry}                % See geometry.pdf to learn the layout options. There are lots.
\geometry{letterpaper}                   % ... or a4paper or a5paper or ... 
\usepackage{amsfonts, amsmath, amssymb, latexsym, mathrsfs, fancyhdr,theorem,  pifont, setspace, verbatim,  qtree, lscape, tipa, linguex, hyperref, wasysym, stmaryrd, natbib,soul, minibox, lipsum, setspace, amssymb, color, multirow, multicol, soul,geometry,graphicx, wrapfig,gb4e,booktabs}
\usepackage[T1]{fontenc}
\usepackage{times}


\geometry{hmargin={1in,1in},vmargin={1in,1in}}

\definecolor{Red}{RGB}{255,0,0}
\newcommand{\red}[1]{\textcolor{Red}{#1}}
\newcommand{\ha}[1]{\textcolor{Red}{[ha: #1]}} 

\title{Haddock Descriptions}
\author{Helena, Liz, Roger}


\begin{document}
\maketitle

<<Model_Parameters_Variables, echo=FALSE, cache=FALSE,warning=FALSE, message=FALSE, fig.width = 13,fig.height=3>>=

# Import libraries
require(ggm)
require(ggpubr)
require(rlist)
require(RJSONIO)
require("rwebppl")


#Repo
#https://github.com/haparici/haddock-descriptions


## Visuals Master ##
refs_json <- '[
  {"Animal": "rabbit", "Container": "bag", "Size": 1}
  , {"Animal": "rabbit", "Container": "bag", "Size": 2}
  , {"Animal": "frog", "Container": "bag", "Size": 3}
  , {"Animal": "frog", "Container": "box", "Size": 1}
  , {"Animal": "rabbit", "Container": "box", "Size": 2}
  , {"Animal": "frog", "Container": "basket", "Size": 3}
  , {"Animal": "rabbit", "Container": "box", "Size": 1}
  ]'

refs <- fromJSON(refs_json)
refs <- do.call("rbind", refs)
refs <- data.frame(refs)

## Visual Logical Constructor ##
conds_idx <- list(
  c(TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE)
  , c(TRUE, TRUE, FALSE, TRUE, TRUE, TRUE, FALSE)
  , c(TRUE, TRUE, TRUE, FALSE, TRUE, FALSE, TRUE)
)

get_visuals <- function(refs, conds_idx, i){
  
  cond_idx <- unlist(conds_idx[i])
  visual <- refs[cond_idx, ]
  
  return(visual)
  
}

## Descriptions ##
sizes <- c('smaller', 'small', 'big', 'bigger', 'empty')
#sizes <- c('smaller', 'bigger', 'empty')
#sizes <- c( 'small', 'big', 'empty')
get_descriptions <- function(visual, sizes) {
  
  visual_unique <- unique(visual[, c("Animal", "Container")])
  
  descs <- list()
  for (ref in 1:nrow(visual_unique)) {
    for (size in sizes) {
      animal <- visual_unique[ref, "Animal"]
      container <- visual_unique[ref, "Container"]
      desc = list(animal, size, container)
      descs <- list.append(descs, unlist(desc))
    }
  }
  desc <- list("none", "none", "none")
  descs <- list.append(descs, unlist(desc))
  
  return(descs)
}

get_costs <- function(descs) {
  
  costs <- list()
  columns <- list()
  
  for (i in 1:length(descs)) {
    
    desc <- unlist(descs[i])
    desc_str <- paste(desc[1], desc[2], desc[3])
    adjective <- desc[2]
    tail <- substr(adjective, nchar(adjective) - 1, nchar(adjective))
    
    if (tail == "er") {
      
      cost <- 1.5
      
    } else if (adjective %in% c("small", "big")) {
      
      cost <- 1
      
    } else if (adjective == "empty") {
      
      cost <- 0.5
      
    } else {
      
      cost <- 0
      
    }
    costs <- list.append(costs, cost)
    columns <- list.append(columns, desc_str)
  }
  costs <- data.frame(costs)
  colnames(costs) <- unlist(columns)
  
  return(costs)
}


##Random Variables##

pos<-list(c("rabbit", "big", "bag"),c("rabbit", "big", "box"))
cmp<-list(c("rabbit", "bigger", "bag"),c("rabbit", "bigger", "box"))

randomVariables<-list(pos,cmp)
#randomVariables<-list(pos)
#randomVariables<-list(cmp)

execute_model <- function(randomVariable, cond, model, context, posMeaning) {
  
  # Model
  visuals <- get_visuals(refs, conds_idx, cond)
  descs <- get_descriptions(visuals, sizes)
  costs <- get_costs(descs)

  model_data <- list(randomVariable, visuals, descs, costs, context, posMeaning)
  
  model <- webppl(program_file=model, data = model_data, data_var = "model_data")
  
  return(model)
  
}

@


<<Model_Main, echo=FALSE, cache=TRUE, warning=FALSE, message=FALSE, fig.width = 13, fig.height=3>>=

## Main ##

# Calling Parameters 
 
conds <- c(1, 2, 3)
contexts <- c("cco","no-cc")
posMeanings <- c("bumford", "standard")
models <- c("haddock_model.wppl")

# Execute Model
results <- data.frame()

for(posMeaning in posMeanings) { 
  for (context in contexts) {
    for (randomVariable in randomVariables) {
      for (cond in conds) {
        for (model in models) {
          result <- execute_model(randomVariable, cond, model,context,posMeaning)
          result$Adjective <- randomVariable[[1]][2]
          result$posMeaning <- posMeaning
          result$Context <- context
          result$Condition <- cond
          result$Model <- model
          results <- rbind(results, result)
          #print(paste("Processing adjective"
          #        , randomVariable[[1]][2]
          #        , "for context"
          #        , context
          #        , "for posMeaning"
          #        , posMeaning
          #        , "for condition"
          #        , cond
          #        , "with model"
          #        , model))
        }
      }
    }
  }
}

colnames(results) <- c(
  "Animal"
  , "Container"
  , "Size"
  , "Probability"
  , "Adjective"
  , "posMeaning"
  , "Context"
  , "Condition"
  , "Model")

#results

@



\section{Experiment}


\subsection{Results}

Experimental results are plotted in Figure \ref{results}, which plots for each of the three contexts tested the probability of bag resolution (proportion of clicks to the rabbit in the medium bag vs. clicks on the the rabbit in the medium box). The yellow line corresponds to chance after correcting for responses that did not correspond to any of these two objects (a total of xxxxx).


%Do we want to regenerate this plot with bootstrap CI's?


Data from xx were discarded either because xxx (N) or because the reported not to be native speakers of American English (XX). After xxx a total of XX participants.


<<results, echo=FALSE, cache=TRUE, warning=FALSE, message=FALSE, fig.width = 8, fig.height=4>>=

require(Rmisc)
require(ggplot2)

#combined_all3_data.csv
data<-read.csv("alldata.csv", header=TRUE) #117 unique IDs

data1<-subset(data, native!="no") 
data2<-subset(data1, data1$mturkid!="Veron") #113 unique IDs

truncatemturkid<-function (str) { substr(str,0,5) }

truncatemturkid("A34SLWTNACPBMO")

badlisteners <- c("A34SLWTNACPBMO","A1LDGTVB4DC9FN","A1ZD8RU6YB0VEU","AK5AFB4VLBCGK","A35IZHRX8T2Q0T","AV8DKC89G7XML","A2GG7HIO2OIXUR","A2CNSIECB9UP05","ANNV3E6CIVCW4")

badlisteners.short <- sapply(badlisteners,truncatemturkid)

length(badlisteners.short)

data3<-subset(data2, !(mturkid%in%badlisteners.short)) #108


unique(data3$mturkid)

#Prolific participants that we want to keep 

setwd("~/Dropbox (MIT)/Haddock-Comparatives/Exp2-PosComp/RealStudy/analysis/prolific1-output")

userinfo1<-read.csv("prolific1-userinfo.csv", header=TRUE)

prolific1Bad<-subset(userinfo1, First.Language!="English") #10

idProlific1Bad<-unique(prolific1Bad$participant_id) #10

setwd("~/Dropbox (MIT)/Haddock-Comparatives/Exp2-PosComp/RealStudy/analysis/prolific2-output")

userinfo2<-read.csv("prolific2-userinfo.csv", header=TRUE)


prolific2Bad<-subset(userinfo2, First.Language!="English")#11

idProlific2Bad<-unique(prolific2Bad$participant_id) #11


data4<-subset(data3,!(mturkid%in%idProlific1Bad)) #103 some participants were not there already. cheaters?

data5<-subset(data4,!(mturkid%in%idProlific2Bad)) #101 some participants were not there already. cheaters?





#prolificparticipantsID<-unique(prolificparticipants$participant_id)

#data3<-subset(data, mturkid%in%prolificparticipantsID) #19 unique IDs
##there are two participants missing?


#data.final<-rbind(data2,data3) #54 unique IDs



data5$stim.version<-paste(data5$stimnum,data5$version,sep="-")

data5$stim.version<-as.factor(data5$stim.version)

data.summary<-summarySE(data5, measurevar="target", 
                        groupvars=c("displaytype","adjtype"))

data.summary$displaytype1[data.summary$displaytype=="abs-rel"]= "Context 1"
data.summary$displaytype1[data.summary$displaytype=="abs-both"]= "Context 2"
data.summary$displaytype1[data.summary$displaytype=="both-rel"]= "Context 3"

data.summary$adjtype2[data.summary$adjtype=="pos"]= "big"
data.summary$adjtype2[data.summary$adjtype=="cmp"]= "bigger"


cbPalette <- c("#009E73", "#CC79A7","#E69F00", "#56B4E9",  
               "#F0E442", "#0072B2", "#D55E00",  "#999999")


results.plot<- ggplot(data.summary, aes(x=displaytype1, y=target, fill=adjtype2)) + 
  geom_bar(position=position_dodge(), stat="identity") +
  scale_fill_manual(values=cbPalette) +
  geom_errorbar(aes(ymin=target-ci, ymax=target+ci),
                width=.2,                    # Width of the error bars
                position=position_dodge(.9)) +
  theme_bw() +
  theme(axis.text.x = element_text(size=15),
        axis.text.y = element_text(size=15),  
        axis.title.x = element_text(size=18),
        axis.title.y = element_text(size=18),
        legend.title=element_text(size=16), 
        legend.text=element_text(size=14)
  ) +
  xlab("Context Type") +
  ylab("Probability of bag resoluion") +
  labs(fill="Adj. Type")

results.plot


@


\noindent
Type of analysis: results for subset data corresponding to the first two conditions:
posterior mean estimate and 95$\%$ credible interval: $\beta$ = $-1.25[-2.63, 0.02]$

<<Stats, echo=FALSE, cache=TRUE, warning=FALSE, message=FALSE, fig.width = 13, fig.height=3>>=

require(dplyr)
require(lmerTest)
#devtools::install_github("paul-buerkner/brms")
require("rstan") 
require(brms)
require(broom)

#data<-read.csv("haddock_clean_data.csv", header=TRUE)
#head(data)


#native column? do we need to discard any data here?
#96 participants. do we need to disccard someone? we have 24 data points from one participant. how about the non-natives?

### frequentist analysis ###


#remove both-rel condition (context 3)

data.interaction2 = subset(data5, displaytype!="both-rel")


#Column we are trying to predict data$target1
#Set reference level to .
#"abs-rel" same/diff+competitor, aka context 1
#"abs-both" same/diff-competitor, aka context 2
#"both-rel" same/same+competitor, aka context 3

#is stim num the right random effect or should it also factor in the a-b manipulation?
#what analysis do we want to report? maybe first subset the for the relevant interaction

#model1.f<-glmer(
#  target1~adjtype*displaytype +
#    (1+adjtype*displaytype | usernum)+(1+adjtype*displaytype|stim.version), 
#  data=data.interaction2, 
#  family=binomial,
#  glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun=2e5))
#) 
#isSingular(model1.f, tol = 1e-05)
#[1] TRUE



### Bayesian analysis ###
#for model comparison loo()
#data.interaction2 comares contexts 1 and 2
#https://mc-stan.org/misc/warnings.html#divergent-transitions-after-warmup



#  model1.b<- brm(
#    formula = target1 ~ adjtype*displaytype +
#      (1+adjtype*displaytype | usernum)+(1+adjtype*displaytype|stim.version),
#    data = data.interaction2,
#    family = "bernoulli",
#    control=list(adapt_delta=0.99),
#    iter = 8000,
#   chains = 4,
#   cores = 4,
#  )
# 
# model1.b

@

\section{Semantic Assumptions}


\section{Computational Model}

We implement a one level RSA model where the pragmatic listener jointly infers a referent by reasoning about 1) possible continuations of the truncated utterance; 2) Likely context partitions that satisfy the semantic requirements of the utterance; 3) Possible threshold values for the relative adjective.


\subsection{Literal Listener}


The Literal Listener assigns prior-based probability to every referent $r$ in context $C$ that satisfies the literal semantics of description $d$, assuming threshold $\theta$ for {\em big} (see semantics below).

%$$L_0(r\given d,C,\theta) \propto \llbracket d \rrbracket^{C,\theta}(r)\cdot P(r)$$

%Problem: This distribution is undefinable if there is no referent in $C$ satisfying $d$! Solution: special \textsf{fail} referent, with prior probability $\epsilon$.

%\begin{center} 
%$P(r) =\epsilon$ if $r = \textsf{fail}$; else uniform among $r\in C$
%\end{center}

%\paragraph{Speaker:} Assigns probabilities to descriptions $d$ given intended referent $r$, context $C$ and threshold $\theta$ that reflect both the probability of the literal listener picking the referent and the cost (length) of $d$.

%$$S_1(d\given r,C,\theta) \propto L_0(r\given d,C,\theta) - \textsf{cost}(d) $$

%We assume the rationality parameter $\alpha = 1$.


%\paragraph{Pragmatic listener:} Assigns probabilities to referents $r$ given (partially masked) description $d$, reflecting the probability of the speaker using (any resolution of) $d$ to describe $r$ in any context $C$ with any threshold $\theta$.

%\medskip

%\noindent
%Marginalizing over $C$, $\theta$, and $N_2$:

%\noindent
%$~~L_1(r\given d=N_1\textnormal{ in the (Adj) }\textsf{[masked]}) \propto \sum_C \sum_\theta \sum_{N_2} S_1(d=N_1\textnormal{ in the (Adj) }N_2\given r,C,\theta)\cdot P(r\given
%C)\cdot P(\theta\given C,d)\cdot P(C)$

%\medskip


%Global context $\mathcal{C} = \{r_1,r_2,r_3,r_4,r_5\}$;
%$P(C)$ is uniform among $\powerset(\mathcal{C})$.



\subsection{Simulations}


<<Plots, echo=FALSE, cache=TRUE, warning=FALSE, message=FALSE, fig.width = 6, fig.height=7>>=

## Plots ##

bags.standard<-subset(results, Container=="bag" & posMeaning=="standard")
bags.bumford<-subset(results, Container=="bag" & posMeaning=="bumford")


cbPalette <- c("#009E73", "#CC79A7","#E69F00", "#56B4E9",  "#F0E442", "#0072B2", "#D55E00",  "#999999")

standard<-ggplot(bags.standard, aes(x=Condition, y=Probability, fill=Adjective)) + 
  geom_bar(position=position_dodge(), stat="identity") +
  scale_fill_manual(values=cbPalette) +
  theme_bw() +
  theme(axis.text.x = element_text(size=8),
        axis.text.y = element_text(size=15),  
        axis.title.x = element_text(size=18),
        axis.title.y = element_text(size=18),
        legend.title=element_text(size=16), 
        legend.text=element_text(size=14)
  ) +
  ylim(0,1) +
  xlab("Display Type") +
  ylab("Bag Resolution") +
  ggtitle("Standard") +
  facet_grid(Context ~ Adjective) +
  labs(fill="Adj. Type")

bumford<-ggplot(bags.bumford, aes(x=Condition, y=Probability, fill=Adjective)) + 
  geom_bar(position=position_dodge(), stat="identity") +
  scale_fill_manual(values=cbPalette) +
  theme_bw() +
  theme(axis.text.x = element_text(size=8),
        axis.text.y = element_text(size=15),  
        axis.title.x = element_text(size=18),
        axis.title.y = element_text(size=18),
        legend.title=element_text(size=16), 
        legend.text=element_text(size=14)
  ) +
  ylim(0,1) +
  xlab("Display Type") +
  ylab("Bag Resolution") +
  ggtitle("Bumford") +
  facet_grid(Context ~ Adjective) +
  labs(fill="Adj. Type")


ggarrange(standard, bumford + rremove("x.text"), 
          heights = c(2, 2.5),
          #labels = c("A", "B", "C"),
          ncol = 1, nrow = 2)
@





\end{document}