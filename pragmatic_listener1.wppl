
// Parameters and Variables
var randomVariable= model_data[0]
var visuals = model_data[1]
var descriptions = model_data[2]
var cost = model_data[3][0]
var cont = model_data[4]
var posMeaning = model_data[5]



var r1 = [visuals[0]["Animal"][0], visuals[0]["Container"][0], visuals[0]["Size"][0]]
var r2 = [visuals[1]["Animal"][0], visuals[1]["Container"][0], visuals[1]["Size"][0]]
var r3 = [visuals[2]["Animal"][0], visuals[2]["Container"][0], visuals[2]["Size"][0]]
var r4 = [visuals[3]["Animal"][0], visuals[3]["Container"][0], visuals[3]["Size"][0]]
var r5 = [visuals[4]["Animal"][0], visuals[4]["Container"][0], visuals[4]["Size"][0]]
var rU = ["", "", ""]

var referents = [r1, r2, r3, r4, r5, rU]

var alpha = 1;

var refs = {
  "referents": [r1, r2, r3, r4, r5, rU],
  "probabilities": [50, 50, 50, 50, 50, 10]
};


var cont1 = [[r1,r2,r3,r4,r5]]
var cont2 = [

    [r1], [r2], [r3], [r4], [r5],

    [r1, r2],
    [r1, r3],
    [r1, r4],
    [r1, r5],
    [r2, r3],
    [r2, r4],
    [r2, r5],
    [r3, r4],
    [r3, r5],
    [r4, r5],

    [r1, r2, r3],
    [r1, r2, r4],
    [r1, r2, r5],
    [r1, r3, r4],
    [r1, r3, r5],
    [r1, r4, r5],
    [r2, r3, r4],
    [r2, r3, r5],
    [r2, r4, r5],
    [r3, r4, r5],

    [r1, r2, r3, r4],
    [r1, r2, r3, r5],
    [r1, r2, r4, r5],
    [r1, r3, r4, r5],
    [r2, r3, r4, r5],

    [r1,r2,r3,r4,r5]
]


var conts = function(cont) {

  if (cont == "no-cc") {

    return cont1

  }

  else {

    return cont2
  }
}


var contexts = conts(cont)


var thresholds = ["0", "1", "2", "3"]


// Functions //

var randomVariablePrior = function() {
   return uniformDraw(randomVariable);
} // this is not a distribution in webppl. if i want to sample() from this i have to use the infer wrapping here

var referentsPrior = function() {
  return categorical(refs.probabilities, refs.referents);
};


//threshold prior relativized to the descriptions's relevant comparison class, k+1 thresholds
var thresholdPriorGivenContext = function(context, description) {
  var cc = function(context, description){
  filter(function(rf){
  rf[1] == description[2]
  }, context) 
  };
  var result = cc(context,description);
  var getThres = map(function(result){ return result[2] }, result )
  getThres.sort()
  getThres.push(getThres[0] - 1); //this line adds k+1 but qualitative results are worse and positive does not run without it. The solution is to add extra threshold only for singleton contexts, i.e. if the cardinality of getThres is 1. If I remove this line the bumford meaning looks like it used to.
  return Infer({method: "enumerate"}, function() {
  uniformDraw(getThres)
  });
};



var referentsPriorGivenContext = function(context) {
  return Infer({method: "enumerate"}, function() {
     flip(0.01) ? rU : uniformDraw(context)
  });
};

var contextsPrior = function() {
    return uniformDraw(contexts);
}

var descriptionPrior = function() {
  var uttProbs = map(function(u) {
    var uKey = typeof u == "string" ? u : u[0] + " " + u[1] + " " + u[2];
         return Math.exp(-cost[uKey])
  }, descriptions);
    return categorical(uttProbs, descriptions);
};

var thresholdsPrior = function() {
    return uniformDraw(thresholds);
}


//// Meaning Function ////

// Positive Function

var positiveStand = function(description, referent, all_referents, theta, context) {

  var innerMatch = function(referent) {

    var sameContainer = description[2] == referent[1] ? true : false
    return sameContainer == true 

  }

  var truthFn = function(referent) {

    var includes = find(function(x) {return x == referent}, context) 
    var inclusion = includes == referent ? true : false
    var sameNoun = description[0] == referent[0] ? true : false
    var threshold =  description[1] == "empty" ? true: description[1] == "big" ? referent[2] > theta : description[1] == "small" ? referent[2] <= theta : false

    return inclusion == true && sameNoun == true && threshold == true && innerMatch(referent)== true && sum(map(innerMatch, all_referents))==1

  }

  return (truthFn(referent) && sum(map(truthFn, all_referents))==1) || _.isEqual(description, ["none", "none", "none"]) || _.isEqual(referent, rU)

}


var positiveBum = function(description, referent, all_referents, theta, context) {

  var innerMatch = function(referent) {

    var sameContainer = description[2] == referent[1] ? true : false

    return sameContainer == true 

  }

  var truthFn = function(referent) {

    var includes = find(function(x) {return x == referent}, context) 
    var inclusion = includes == referent ? true : false
    var sameNoun = description[0] == referent[0] ? true : false
    var threshold =  description[1] == "empty" ? true: description[1] == "big" ? referent[2] > theta : description[1] == "small" ? referent[2] <= theta : false

    return inclusion == true && sameNoun == true && threshold == true && innerMatch(referent)

  }

  return (truthFn(referent) && sum(map(truthFn, all_referents))==1) || _.isEqual(description, ["none", "none", "none"]) || _.isEqual(referent, rU)

}





var pos = function(posMeaning) {

  if (posMeaning == "standard") {

    return positiveStand

  }

  else {

    return positiveBum
  }
}


var positive = pos(posMeaning)


// Comparative Function
var comparative = function(description, referent, all_referents, theta, context) {

  var innerMatch = function(referent) {

    var sameContainer = description[2] == referent[1] ? true : false

    return sameContainer == true

  }

  var truthFn = function(referent) {

    var includes = find(function(x) { return x == referent }, context) 
    var inclusion = includes == referent ? true : false 
    var sameNoun = description[0] == referent[0]  ? true : false 
    
    return sameNoun == true && inclusion == true && innerMatch(referent)

  }
  
  var cardinalityCheck = function(scope) {
    
    if (scope == "low") {
      return description[1] == "empty" ? true : description[1] == "bigger" ? sum(map(innerMatch, all_referents)) == 2 : false
    } 

    else {
      return description[1] == "empty" ? true : description[1] == "bigger" ? sum(map(truthFn, all_referents)) == 2 : false
    }
    
  }

  var thresholdFn = function(referent, scope) {

    var threshold =  description[1] == "empty" ? true : description[1] == "bigger" ? referent[2] > theta : description[1] == "smaller" ? referent[2] <= theta : false

    return (threshold == true && cardinalityCheck(scope) == true && truthFn(referent)) || _.isEqual(description, ["none", "none", "none"]) || _.isEqual(referent, rU)

  }
  
  return sample(Infer({method: "enumerate"}, function() {flip(0.01) ? thresholdFn(referent, "low") : thresholdFn(referent, "high")}))
  
}

var meaning = function(description, referent, all_referents, theta, context) {

  var adjective = description[1]

  if (adjective.substr(-2) == "er") {

    return comparative(description, referent, all_referents, theta, context)

  }

  else {

    return positive(description, referent, all_referents, theta, context)

  }

}

//// End of Meaning Function ////

var literalListener = function(description, context, theta) {
    return Infer({method: "enumerate"}, function() {
    var referent = referentsPrior();
    var all_referents = context; 
    condition(meaning(description, referent, all_referents, theta, context))
    return referent;
  });
}  

var speaker = function(referent, context, theta) {
  return Infer({method: "enumerate"}, function() {
    var description = descriptionPrior();
    factor( alpha * literalListener(description, context, theta).score(referent));
    return description;
  });
}

var pragmaticListener = function(description) {
  return Infer({method: "enumerate"}, function() {
    var description = randomVariablePrior();
    var context = contextsPrior(); 
    var referent = sample(referentsPriorGivenContext(context));
    var theta = sample(thresholdPriorGivenContext(context,description)); 
    factor(speaker(referent, context, theta).score(description));
    condition(referent[0]=="rabbit")
    return {thet: theta, cont: context, ref: referent}; 
  });
};

// Main

marginalize(pragmaticListener("rabbit","adjective","silence"), "ref")



//TODO: pragmaticlistener2 to repository